import {
  __commonJS
} from "./chunk-DC5AMYBS.js";

// node_modules/depd/lib/browser/index.js
var require_browser = __commonJS({
  "node_modules/depd/lib/browser/index.js"(exports, module) {
    "use strict";
    module.exports = depd;
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate(message) {
      }
      deprecate._file = void 0;
      deprecate._ignored = true;
      deprecate._namespace = namespace;
      deprecate._traced = false;
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tsscmp/lib/index.js
var require_lib = __commonJS({
  "node_modules/tsscmp/lib/index.js"(exports, module) {
    "use strict";
    var crypto = require_crypto();
    function bufferEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      if (crypto.timingSafeEqual) {
        return crypto.timingSafeEqual(a, b);
      }
      for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    function timeSafeCompare(a, b) {
      var sa = String(a);
      var sb = String(b);
      var key = crypto.pseudoRandomBytes(32);
      var ah = crypto.createHmac("sha256", key).update(sa).digest();
      var bh = crypto.createHmac("sha256", key).update(sb).digest();
      return bufferEqual(ah, bh) && a === b;
    }
    module.exports = timeSafeCompare;
  }
});

// node_modules/keygrip/index.js
var require_keygrip = __commonJS({
  "node_modules/keygrip/index.js"(exports, module) {
    "use strict";
    var compare = require_lib();
    var crypto = require_crypto();
    function Keygrip(keys, algorithm, encoding) {
      if (!algorithm) algorithm = "sha1";
      if (!encoding) encoding = "base64";
      if (!(this instanceof Keygrip)) return new Keygrip(keys, algorithm, encoding);
      if (!keys || !(0 in keys)) {
        throw new Error("Keys must be provided.");
      }
      function sign(data, key) {
        return crypto.createHmac(algorithm, key).update(data).digest(encoding).replace(/\/|\+|=/g, function(x) {
          return { "/": "_", "+": "-", "=": "" }[x];
        });
      }
      this.sign = function(data) {
        return sign(data, keys[0]);
      };
      this.verify = function(data, digest) {
        return this.index(data, digest) > -1;
      };
      this.index = function(data, digest) {
        for (var i = 0, l = keys.length; i < l; i++) {
          if (compare(digest, sign(data, keys[i]))) {
            return i;
          }
        }
        return -1;
      };
    }
    Keygrip.sign = Keygrip.verify = Keygrip.index = function() {
      throw new Error("Usage: require('keygrip')(<array-of-keys>)");
    };
    module.exports = Keygrip;
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/cookies/index.js"(exports, module) {
    var deprecate = require_browser()("cookies");
    var Keygrip = require_keygrip();
    var http = require_http();
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    var PRIORITY_REGEXP = /^(?:low|medium|high)$/i;
    var REGEXP_CACHE = /* @__PURE__ */ Object.create(null);
    var REGEXP_ESCAPE_CHARS_REGEXP = /[\^$\\.*+?()[\]{}|]/g;
    var RESTRICTED_NAME_CHARS_REGEXP = /[;=]/;
    var RESTRICTED_VALUE_CHARS_REGEXP = /[;]/;
    var SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
    function Cookies(request, response, options) {
      if (!(this instanceof Cookies)) return new Cookies(request, response, options);
      this.secure = void 0;
      this.request = request;
      this.response = response;
      if (options) {
        if (Array.isArray(options)) {
          deprecate('"keys" argument; provide using options {"keys": [...]}');
          this.keys = new Keygrip(options);
        } else if (options.constructor && options.constructor.name === "Keygrip") {
          deprecate('"keys" argument; provide using options {"keys": keygrip}');
          this.keys = options;
        } else {
          this.keys = Array.isArray(options.keys) ? new Keygrip(options.keys) : options.keys;
          this.secure = options.secure;
        }
      }
    }
    Cookies.prototype.get = function(name, opts) {
      var sigName = name + ".sig", header, match, value, remote, data, index, signed = opts && opts.signed !== void 0 ? opts.signed : !!this.keys;
      header = this.request.headers["cookie"];
      if (!header) return;
      match = header.match(getPattern(name));
      if (!match) return;
      value = match[1];
      if (value[0] === '"') value = value.slice(1, -1);
      if (!opts || !signed) return value;
      remote = this.get(sigName);
      if (!remote) return;
      data = name + "=" + value;
      if (!this.keys) throw new Error(".keys required for signed cookies");
      index = this.keys.index(data, remote);
      if (index < 0) {
        this.set(sigName, null, { path: "/", signed: false });
      } else {
        index && this.set(sigName, this.keys.sign(data), { signed: false });
        return value;
      }
    };
    Cookies.prototype.set = function(name, value, opts) {
      var res = this.response, req = this.request, headers = res.getHeader("Set-Cookie") || [], cookie = new Cookie(name, value, opts), signed = opts && opts.signed !== void 0 ? opts.signed : !!this.keys;
      var secure = this.secure === void 0 ? req.protocol === "https" || isRequestEncrypted(req) : Boolean(this.secure);
      if (typeof headers == "string") headers = [headers];
      if (!secure && opts && opts.secure) {
        throw new Error("Cannot send secure cookie over unencrypted connection");
      }
      cookie.secure = opts && opts.secure !== void 0 ? opts.secure : secure;
      if (opts && "secureProxy" in opts) {
        deprecate('"secureProxy" option; use "secure" option, provide "secure" to constructor if needed');
        cookie.secure = opts.secureProxy;
      }
      pushCookie(headers, cookie);
      if (opts && signed) {
        if (!this.keys) throw new Error(".keys required for signed cookies");
        cookie.value = this.keys.sign(cookie.toString());
        cookie.name += ".sig";
        pushCookie(headers, cookie);
      }
      var setHeader = res.set ? http.OutgoingMessage.prototype.setHeader : res.setHeader;
      setHeader.call(res, "Set-Cookie", headers);
      return this;
    };
    function Cookie(name, value, attrs) {
      if (!fieldContentRegExp.test(name) || RESTRICTED_NAME_CHARS_REGEXP.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      if (value && (!fieldContentRegExp.test(value) || RESTRICTED_VALUE_CHARS_REGEXP.test(value))) {
        throw new TypeError("argument value is invalid");
      }
      this.name = name;
      this.value = value || "";
      for (var name in attrs) {
        this[name] = attrs[name];
      }
      if (!this.value) {
        this.expires = /* @__PURE__ */ new Date(0);
        this.maxAge = null;
      }
      if (this.path && !fieldContentRegExp.test(this.path)) {
        throw new TypeError("option path is invalid");
      }
      if (this.domain && !fieldContentRegExp.test(this.domain)) {
        throw new TypeError("option domain is invalid");
      }
      if (typeof this.maxAge === "number" ? isNaN(this.maxAge) || !isFinite(this.maxAge) : this.maxAge) {
        throw new TypeError("option maxAge is invalid");
      }
      if (this.priority && !PRIORITY_REGEXP.test(this.priority)) {
        throw new TypeError("option priority is invalid");
      }
      if (this.sameSite && this.sameSite !== true && !SAME_SITE_REGEXP.test(this.sameSite)) {
        throw new TypeError("option sameSite is invalid");
      }
    }
    Cookie.prototype.path = "/";
    Cookie.prototype.expires = void 0;
    Cookie.prototype.domain = void 0;
    Cookie.prototype.httpOnly = true;
    Cookie.prototype.partitioned = false;
    Cookie.prototype.priority = void 0;
    Cookie.prototype.sameSite = false;
    Cookie.prototype.secure = false;
    Cookie.prototype.overwrite = false;
    Cookie.prototype.toString = function() {
      return this.name + "=" + this.value;
    };
    Cookie.prototype.toHeader = function() {
      var header = this.toString();
      if (this.maxAge) this.expires = new Date(Date.now() + this.maxAge);
      if (this.path) header += "; path=" + this.path;
      if (this.expires) header += "; expires=" + this.expires.toUTCString();
      if (this.domain) header += "; domain=" + this.domain;
      if (this.priority) header += "; priority=" + this.priority.toLowerCase();
      if (this.sameSite) header += "; samesite=" + (this.sameSite === true ? "strict" : this.sameSite.toLowerCase());
      if (this.secure) header += "; secure";
      if (this.httpOnly) header += "; httponly";
      if (this.partitioned) header += "; partitioned";
      return header;
    };
    Object.defineProperty(Cookie.prototype, "maxage", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.maxAge;
      },
      set: function(val) {
        return this.maxAge = val;
      }
    });
    deprecate.property(Cookie.prototype, "maxage", '"maxage"; use "maxAge" instead');
    function getPattern(name) {
      if (!REGEXP_CACHE[name]) {
        REGEXP_CACHE[name] = new RegExp(
          "(?:^|;) *" + name.replace(REGEXP_ESCAPE_CHARS_REGEXP, "\\$&") + "=([^;]*)"
        );
      }
      return REGEXP_CACHE[name];
    }
    function isRequestEncrypted(req) {
      return req.socket ? req.socket.encrypted : req.connection.encrypted;
    }
    function pushCookie(headers, cookie) {
      if (cookie.overwrite) {
        for (var i = headers.length - 1; i >= 0; i--) {
          if (headers[i].indexOf(cookie.name + "=") === 0) {
            headers.splice(i, 1);
          }
        }
      }
      headers.push(cookie.toHeader());
    }
    Cookies.connect = Cookies.express = function(keys) {
      return function(req, res, next) {
        req.cookies = res.cookies = new Cookies(req, res, {
          keys
        });
        next();
      };
    };
    Cookies.Cookie = Cookie;
    module.exports = Cookies;
  }
});
export default require_cookies();
/*! Bundled license information:

depd/lib/browser/index.js:
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

keygrip/index.js:
  (*!
   * keygrip
   * Copyright(c) 2011-2014 Jed Schmidt
   * MIT Licensed
   *)

cookies/index.js:
  (*!
   * cookies
   * Copyright(c) 2014 Jed Schmidt, http://jed.is/
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=cookies.js.map
